# Qt-Theme-Studio 機能仕様書

## 概要

Qt-Theme-Studioの各機能の詳細仕様を記載します。実装時の参考資料として使用してください。

## 1. ゼブラパターン機能

### 1.1 概要
テーブルやリストでの可読性向上のため、WCAG準拠の交互背景色を自動生成する機能。

### 1.2 機能要件

#### 基本機能
- **自動色生成**: ベース色から最適な交互色を生成
- **WCAG準拠**: AA/AAAレベルのコントラスト比を保証
- **リアルタイムプレビュー**: 変更を即座に確認
- **カスタマイズ**: 明度・彩度の手動調整

#### 技術仕様
```python
class ZebraPatternGenerator:
    def generate_pattern(
        self,
        base_color: str,          # ベース色 (#ffffff形式)
        contrast_level: str,      # "AA" または "AAA"
        brightness_offset: float = 0.05,  # 明度オフセット
        saturation_factor: float = 0.95   # 彩度係数
    ) -> Dict[str, str]:
        """
        Returns:
        {
            "primary": "#ffffff",      # プライマリ色
            "alternate": "#f8f8f8",    # 交互色
            "text": "#000000",         # テキスト色
            "border": "#e0e0e0"        # ボーダー色
        }
        """
```

#### UI仕様
```
┌─────────────────────────────────────┐
│ ゼブラパターン生成                    │
├─────────────────────────────────────┤
│ ベース色: [#ffffff] [色選択ボタン]     │
│ レベル:   [AA ▼] [AAA]              │
│ 明度調整: [────●────] 5%            │
│ 彩度調整: [──●──────] 95%           │
├─────────────────────────────────────┤
│ プレビュー:                         │
│ ┌─────────────────────────────────┐ │
│ │ 行1: プライマリ背景               │ │
│ │ 行2: 交互背景                   │ │
│ │ 行3: プライマリ背景               │ │
│ │ 行4: 交互背景                   │ │
│ └─────────────────────────────────┘ │
├─────────────────────────────────────┤
│ コントラスト比: 4.8:1 ✅ AA準拠      │
│ [生成] [リセット] [適用]             │
└─────────────────────────────────────┘
```

### 1.3 アルゴリズム仕様

#### コントラスト比計算
```python
def calculate_contrast_ratio(color1: str, color2: str) -> float:
    """WCAG 2.1準拠のコントラスト比計算"""
    l1 = get_relative_luminance(color1)
    l2 = get_relative_luminance(color2)
    
    lighter = max(l1, l2)
    darker = min(l1, l2)
    
    return (lighter + 0.05) / (darker + 0.05)

def get_relative_luminance(color: str) -> float:
    """相対輝度計算"""
    r, g, b = hex_to_rgb(color)
    
    # sRGB色空間での線形化
    r_linear = linearize_srgb(r / 255.0)
    g_linear = linearize_srgb(g / 255.0)
    b_linear = linearize_srgb(b / 255.0)
    
    # ITU-R BT.709係数での輝度計算
    return 0.2126 * r_linear + 0.7152 * g_linear + 0.0722 * b_linear
```

#### 交互色生成アルゴリズム
```python
def generate_alternate_color(
    base_color: str,
    brightness_offset: float,
    saturation_factor: float
) -> str:
    """交互色生成"""
    h, s, l = rgb_to_hsl(hex_to_rgb(base_color))
    
    # 明度調整
    l_alt = max(0, min(1, l + brightness_offset))
    
    # 彩度調整
    s_alt = s * saturation_factor
    
    # RGB変換
    r, g, b = hsl_to_rgb(h, s_alt, l_alt)
    
    return rgb_to_hex(r, g, b)
```

## 2. 高度なカラーパレット機能

### 2.1 概要
色彩理論に基づく調和色の自動生成とカラーブラインドネス対応機能。

### 2.2 機能要件

#### ハーモニーカラー生成
- **補色**: 色相環で180度対向する色
- **三色配色**: 120度間隔の3色
- **類似色**: 隣接する色相の組み合わせ
- **分割補色**: 補色の両隣の色

#### 技術仕様
```python
class ColorHarmonyGenerator:
    def generate_complementary(self, base_color: str) -> str:
        """補色生成"""
        h, s, l = rgb_to_hsl(hex_to_rgb(base_color))
        h_comp = (h + 180) % 360
        return hsl_to_hex(h_comp, s, l)
    
    def generate_triadic(self, base_color: str) -> List[str]:
        """三色配色生成"""
        h, s, l = rgb_to_hsl(hex_to_rgb(base_color))
        return [
            hsl_to_hex(h, s, l),
            hsl_to_hex((h + 120) % 360, s, l),
            hsl_to_hex((h + 240) % 360, s, l)
        ]
    
    def generate_analogous(self, base_color: str, count: int = 5) -> List[str]:
        """類似色生成"""
        h, s, l = rgb_to_hsl(hex_to_rgb(base_color))
        step = 30  # 30度間隔
        
        colors = []
        for i in range(count):
            h_analog = (h + (i - count//2) * step) % 360
            colors.append(hsl_to_hex(h_analog, s, l))
        
        return colors
```

### 2.3 カラーブラインドネス対応

#### 色覚異常シミュレーション
```python
class ColorBlindnessSimulator:
    def simulate_protanopia(self, color: str) -> str:
        """1型色覚（赤色盲）シミュレーション"""
        r, g, b = hex_to_rgb(color)
        
        # Brettel et al. (1997) アルゴリズム
        r_sim = 0.152286 * r + 1.052583 * g + -0.204868 * b
        g_sim = 0.114503 * r + 0.786281 * g + 0.099216 * b
        b_sim = -0.003882 * r + -0.048116 * g + 1.051998 * b
        
        return rgb_to_hex(
            max(0, min(255, int(r_sim))),
            max(0, min(255, int(g_sim))),
            max(0, min(255, int(b_sim)))
        )
    
    def simulate_deuteranopia(self, color: str) -> str:
        """2型色覚（緑色盲）シミュレーション"""
        # 実装...
        pass
    
    def simulate_tritanopia(self, color: str) -> str:
        """3型色覚（青色盲）シミュレーション"""
        # 実装...
        pass
```

## 3. テーマエクスポート機能

### 3.1 概要
生成したテーマを様々な形式でエクスポートする機能。

### 3.2 対応形式

#### CSS形式
```css
/* Generated by Qt-Theme-Studio */
:root {
  --primary-color: #007acc;
  --background-color: #ffffff;
  --text-color: #333333;
  --accent-color: #ff6b6b;
}

.theme-primary {
  background-color: var(--primary-color);
  color: var(--text-color);
}

.theme-zebra-row:nth-child(even) {
  background-color: #f8f8f8;
}
```

#### Qt StyleSheet形式
```css
/* Qt StyleSheet Export */
QWidget {
    background-color: #ffffff;
    color: #333333;
    font-family: "Segoe UI", Arial, sans-serif;
    font-size: 12px;
}

QPushButton {
    background-color: #007acc;
    color: #ffffff;
    border: 1px solid #007acc;
    padding: 5px 10px;
    border-radius: 3px;
}

QListWidget {
    alternate-background-color: #f8f8f8;
}
```

#### Sass/SCSS形式
```scss
// Theme Variables
$primary-color: #007acc;
$background-color: #ffffff;
$text-color: #333333;
$accent-color: #ff6b6b;

// Mixins
@mixin theme-button($bg-color: $primary-color) {
  background-color: $bg-color;
  color: contrast-color($bg-color);
  border: 1px solid $bg-color;
  
  &:hover {
    background-color: darken($bg-color, 10%);
  }
}

// Components
.btn-primary {
  @include theme-button($primary-color);
}
```

### 3.3 エクスポート設定

#### UI仕様
```
┌─────────────────────────────────────┐
│ テーマエクスポート                    │
├─────────────────────────────────────┤
│ 形式選択:                           │
│ ☑ CSS Variables                    │
│ ☑ Qt StyleSheet                    │
│ ☐ Sass/SCSS                       │
│ ☐ JSON                            │
├─────────────────────────────────────┤
│ オプション:                         │
│ ☑ コメント付き                      │
│ ☑ 圧縮形式                         │
│ ☐ ベンダープレフィックス             │
├─────────────────────────────────────┤
│ プレビュー:                         │
│ ┌─────────────────────────────────┐ │
│ │ :root {                        │ │
│ │   --primary: #007acc;          │ │
│ │   --background: #ffffff;       │ │
│ │ }                              │ │
│ └─────────────────────────────────┘ │
├─────────────────────────────────────┤
│ [エクスポート] [プレビュー] [コピー]  │
└─────────────────────────────────────┘
```

## 4. テーマ統合・マージ機能

### 4.1 概要
複数のテーマファイルを選択して統合し、調和の取れた新しいテーマを生成する機能。

### 4.2 機能要件

#### 基本機能
- **複数選択**: ファイルダイアログでの複数テーマ選択
- **差分解析**: テーマ構造の自動分析
- **インテリジェントマージ**: 色調和性を考慮した統合
- **競合解決**: ユーザーフレンドリーな競合解決UI
- **プレビュー**: マージ結果のリアルタイムプレビュー

#### 技術仕様
```python
class ThemeMerger:
    def __init__(self):
        self.color_analyzer = ColorHarmonyAnalyzer()
        self.conflict_resolver = ConflictResolver()
    
    def merge_themes(
        self,
        theme_files: List[str],
        merge_strategy: str = "intelligent",  # "intelligent", "priority", "manual"
        priority_order: List[str] = None
    ) -> Dict[str, Any]:
        """
        複数テーマのマージ
        
        Args:
            theme_files: テーマファイルパスのリスト
            merge_strategy: マージ戦略
            priority_order: 優先順位（priority戦略時）
            
        Returns:
            マージされたテーマデータ
        """
        themes = [self.load_theme(file) for file in theme_files]
        
        # 構造解析
        structure_analysis = self.analyze_theme_structures(themes)
        
        # 競合検出
        conflicts = self.detect_conflicts(themes, structure_analysis)
        
        # マージ実行
        if merge_strategy == "intelligent":
            merged = self.intelligent_merge(themes, conflicts)
        elif merge_strategy == "priority":
            merged = self.priority_merge(themes, priority_order)
        else:  # manual
            merged = self.manual_merge(themes, conflicts)
        
        return merged
    
    def intelligent_merge(
        self,
        themes: List[Dict[str, Any]],
        conflicts: List['ThemeConflict']
    ) -> Dict[str, Any]:
        """インテリジェントマージ"""
        merged = {}
        
        # 色調和性分析
        for conflict in conflicts:
            if conflict.type == "color":
                # 最も調和の取れた色を選択
                best_color = self.color_analyzer.find_most_harmonious(
                    conflict.values, merged.get('colors', {})
                )
                self.set_nested_value(merged, conflict.path, best_color)
            elif conflict.type == "font":
                # フォントの互換性チェック
                compatible_font = self.find_compatible_font(conflict.values)
                self.set_nested_value(merged, conflict.path, compatible_font)
        
        return merged
```

#### UI仕様
```
┌─────────────────────────────────────────────────────────┐
│ テーマ統合・マージ                                        │
├─────────────────────────────────────────────────────────┤
│ ファイル選択:                                           │
│ ┌─────────────────────────────────────────────────────┐ │
│ │ ☑ theme1.json    [プレビュー] [削除]                │ │
│ │ ☑ theme2.json    [プレビュー] [削除]                │ │
│ │ ☑ theme3.json    [プレビュー] [削除]                │ │
│ └─────────────────────────────────────────────────────┘ │
│ [ファイル追加] [全て選択] [全て解除]                      │
├─────────────────────────────────────────────────────────┤
│ マージ戦略:                                             │
│ ○ インテリジェント (推奨) - 色調和性を考慮              │
│ ○ 優先順位ベース - 上から順に優先                      │
│ ○ 手動選択 - 競合を個別に解決                          │
├─────────────────────────────────────────────────────────┤
│ 競合解決: (3件の競合が検出されました)                    │
│ ┌─────────────────────────────────────────────────────┐ │
│ │ プライマリ色の競合:                                 │ │
│ │ ○ #007acc (theme1.json) ■                         │ │
│ │ ○ #ff6b6b (theme2.json) ■                         │ │
│ │ ○ #28a745 (theme3.json) ■                         │ │
│ │ ○ カスタム: [#______] [色選択]                      │ │
│ └─────────────────────────────────────────────────────┘ │
├─────────────────────────────────────────────────────────┤
│ プレビュー:                                             │
│ ┌─────────────────────────────────────────────────────┐ │
│ │ [マージ結果のライブプレビュー表示]                    │ │
│ └─────────────────────────────────────────────────────┘ │
├─────────────────────────────────────────────────────────┤
│ [マージ実行] [プレビュー更新] [リセット]                  │
└─────────────────────────────────────────────────────────┘
```

### 4.3 マージアルゴリズム

#### 色調和性分析
```python
class ColorHarmonyAnalyzer:
    def find_most_harmonious(
        self,
        candidate_colors: List[str],
        existing_colors: Dict[str, str]
    ) -> str:
        """最も調和の取れた色を選択"""
        best_color = candidate_colors[0]
        best_score = 0
        
        for color in candidate_colors:
            score = self.calculate_harmony_score(color, existing_colors)
            if score > best_score:
                best_score = score
                best_color = color
        
        return best_color
    
    def calculate_harmony_score(
        self,
        color: str,
        existing_colors: Dict[str, str]
    ) -> float:
        """調和スコア計算"""
        if not existing_colors:
            return 1.0
        
        total_score = 0
        count = 0
        
        for existing_color in existing_colors.values():
            # 色相差による調和性
            hue_harmony = self.calculate_hue_harmony(color, existing_color)
            
            # 彩度・明度の調和性
            saturation_harmony = self.calculate_saturation_harmony(color, existing_color)
            lightness_harmony = self.calculate_lightness_harmony(color, existing_color)
            
            # 総合スコア
            harmony_score = (hue_harmony + saturation_harmony + lightness_harmony) / 3
            total_score += harmony_score
            count += 1
        
        return total_score / count if count > 0 else 1.0
```

## 5. スマートインポート/エクスポートシステム

### 5.1 概要
主要なテーマ形式を自動検出し、専用アダプターで高品質な変換を実現する機能。完全可逆ではないが、実用的な品質を保証。

### 5.2 機能要件

#### スマート形式検出
- **既知形式の識別**: 主要テーマ形式のパターンマッチング
- **信頼度スコア**: 検出結果の確信度表示
- **メタデータ抽出**: 作成者情報、バージョン等の保持
- **変換品質評価**: インポート/エクスポート品質の可視化

#### 技術仕様
```python
class SmartImportExportSystem:
    def __init__(self):
        self.format_detectors = {
            'vscode': VSCodeFormatDetector(),
            'sublime': SublimeFormatDetector(),
            'atom': AtomFormatDetector(),
            'jetbrains': JetBrainsFormatDetector()
        }
        self.adapters = {
            'vscode': VSCodeAdapter(),
            'sublime': SublimeAdapter(),
            'atom': AtomAdapter(),
            'jetbrains': JetBrainsAdapter()
        }
        self.quality_evaluator = QualityEvaluator()
    
    def import_theme(self, file_path: str) -> Dict[str, Any]:
        """スマートインポート実行"""
        raw_data = self.load_json_file(file_path)
        
        # 形式検出
        detection_results = self.detect_format(raw_data)
        best_match = max(detection_results, key=lambda x: x['confidence'])
        
        if best_match['confidence'] < 0.7:
            # 信頼度が低い場合は汎用処理
            return self.generic_import(raw_data, file_path)
        
        # 専用アダプターで変換
        adapter = self.adapters[best_match['format']]
        theme_data = adapter.import_data(raw_data)
        
        # メタデータ追加
        theme_data['_import_metadata'] = {
            'source_file': file_path,
            'detected_format': best_match['format'],
            'confidence': best_match['confidence'],
            'quality_score': self.quality_evaluator.evaluate_import(raw_data, theme_data),
            'preserved_fields': adapter.get_preserved_fields(),
            'lost_fields': adapter.get_lost_fields(),
            'original_data_hash': self.calculate_hash(raw_data)
        }
        
        return theme_data
    
    def detect_format(self, data: Dict[str, Any]) -> List[Dict[str, Any]]:
        """形式検出（複数候補を信頼度付きで返す）"""
        results = []
        
        for format_name, detector in self.format_detectors.items():
            confidence = detector.calculate_confidence(data)
            results.append({
                'format': format_name,
                'confidence': confidence,
                'indicators': detector.get_indicators(data)
            })
        
        return sorted(results, key=lambda x: x['confidence'], reverse=True)

#### 形式検出器の実装例
```python
class VSCodeFormatDetector:
    """VS Code テーマ形式検出器"""
    
    def calculate_confidence(self, data: Dict[str, Any]) -> float:
        """信頼度計算（0.0-1.0）"""
        score = 0.0
        indicators = []
        
        # 必須フィールドの確認
        if 'colors' in data:
            score += 0.3
            indicators.append('colors_field_present')
        
        if 'tokenColors' in data:
            score += 0.3
            indicators.append('tokenColors_field_present')
        
        # VS Code特有のフィールド
        vscode_fields = ['name', 'type', 'semanticHighlighting']
        for field in vscode_fields:
            if field in data:
                score += 0.1
                indicators.append(f'{field}_field_present')
        
        # 色の形式チェック
        if 'colors' in data and isinstance(data['colors'], dict):
            vscode_color_keys = [
                'editor.background', 'editor.foreground',
                'activityBar.background', 'statusBar.background'
            ]
            matching_keys = sum(1 for key in vscode_color_keys if key in data['colors'])
            if matching_keys > 0:
                score += min(0.3, matching_keys * 0.1)
                indicators.append(f'{matching_keys}_vscode_color_keys')
        
        return min(1.0, score)
    
    def get_indicators(self, data: Dict[str, Any]) -> List[str]:
        """検出根拠の取得"""
        indicators = []
        
        if 'colors' in data:
            indicators.append('VS Code colors object found')
        if 'tokenColors' in data:
            indicators.append('VS Code tokenColors array found')
        if data.get('type') == 'dark' or data.get('type') == 'light':
            indicators.append(f'VS Code theme type: {data.get("type")}')
        
        return indicators

class SublimeFormatDetector:
    """Sublime Text テーマ形式検出器"""
    
    def calculate_confidence(self, data: Dict[str, Any]) -> float:
        score = 0.0
        
        # Sublime特有の構造
        if 'variables' in data:
            score += 0.4
        
        if 'rules' in data and isinstance(data['rules'], list):
            score += 0.4
        
        # Sublime特有のフィールド
        sublime_fields = ['author', 'uuid', 'semanticClass']
        for field in sublime_fields:
            if field in data:
                score += 0.1
        
        # スコープパターンの確認
        if 'rules' in data:
            for rule in data.get('rules', []):
                if 'scope' in rule and isinstance(rule['scope'], str):
                    if any(scope in rule['scope'] for scope in ['source', 'comment', 'string']):
                        score += 0.1
                        break
        
        return min(1.0, score)
    
    def get_indicators(self, data: Dict[str, Any]) -> List[str]:
        indicators = []
        
        if 'variables' in data:
            indicators.append('Sublime Text variables found')
        if 'rules' in data:
            indicators.append('Sublime Text rules array found')
        if 'uuid' in data:
            indicators.append('Sublime Text UUID found')
        
        return indicators

#### 品質評価システム
```python
class QualityEvaluator:
    """変換品質の評価"""
    
    def evaluate_import(
        self,
        original_data: Dict[str, Any],
        converted_data: Dict[str, Any]
    ) -> Dict[str, Any]:
        """インポート品質評価"""
        
        # 基本メトリクス
        original_fields = self.count_fields(original_data)
        converted_fields = self.count_fields(converted_data.get('colors', {}))
        
        # 色情報の保持率
        original_colors = self.extract_colors(original_data)
        converted_colors = self.extract_colors(converted_data.get('colors', {}))
        color_preservation = len(converted_colors) / max(len(original_colors), 1)
        
        # セマンティック情報の保持
        semantic_score = self.evaluate_semantic_preservation(original_data, converted_data)
        
        # 総合スコア計算
        overall_score = (color_preservation * 0.5 + semantic_score * 0.3 + 
                        min(converted_fields / max(original_fields, 1), 1.0) * 0.2)
        
        return {
            'overall_score': round(overall_score, 2),
            'color_preservation': round(color_preservation, 2),
            'semantic_preservation': round(semantic_score, 2),
            'field_coverage': round(converted_fields / max(original_fields, 1), 2),
            'original_field_count': original_fields,
            'converted_field_count': converted_fields,
            'quality_level': self.get_quality_level(overall_score)
        }
    
    def get_quality_level(self, score: float) -> str:
        """品質レベルの判定"""
        if score >= 0.9:
            return "優秀（90%以上）"
        elif score >= 0.8:
            return "良好（80-89%）"
        elif score >= 0.7:
            return "普通（70-79%）"
        elif score >= 0.6:
            return "要改善（60-69%）"
        else:
            return "低品質（60%未満）"

### 5.3 段階的実装アプローチ

#### Phase 1: 基本実装（短期）
```python
# 最小限の実装
SUPPORTED_FORMATS = {
    'vscode': {
        'detector': simple_vscode_detection,
        'adapter': VSCodeBasicAdapter,
        'priority': 1
    },
    'sublime': {
        'detector': simple_sublime_detection,
        'adapter': SublimeBasicAdapter,
        'priority': 2
    }
}

def simple_vscode_detection(data):
    """シンプルなVS Code検出"""
    score = 0
    if 'colors' in data and 'tokenColors' in data:
        score = 0.9
    elif 'colors' in data:
        score = 0.6
    return score
```

#### Phase 2: 品質向上（中期）
- より精密な形式検出
- 品質評価システムの実装
- ユーザーによる手動調整機能
- より多くの形式への対応

#### Phase 3: 高度な機能（長期）
- 機械学習による形式推論
- ユーザー学習機能
- カスタムアダプター作成支援

### 5.4 実装の利点

✅ **技術的実現可能性**: 既知形式への対応は確実に実装可能  
✅ **段階的改善**: 基本機能から始めて徐々に拡張  
✅ **品質の可視化**: ユーザーが変換品質を理解できる  
✅ **拡張性**: 新しい形式への対応が容易  

### 5.5 制限事項

⚠️ **完全可逆性なし**: 一部情報の損失は避けられない  
⚠️ **未知形式への対応限界**: 汎用的な対応は困難  
⚠️ **メンテナンス負荷**: 新しい形式への対応が必要
        """スマートインポート"""
        # ファイル読み込み
        raw_data = self.load_json_file(file_path)
        
        # 形式検出
        detection_result = self.detect_format(raw_data)
        
        # 適切なアダプター選択
        adapter = self.get_adapter(detection_result.format_name)
        
        # 変換実行
        theme_data = adapter.import_data(raw_data)
        
        # 品質評価
        quality_score = self.quality_evaluator.evaluate_import(
            raw_data, theme_data, adapter
        )
        
        # メタデータ保存
        theme_data['_import_info'] = {
            'original_format': detection_result.format_name,
            'detection_confidence': detection_result.confidence,
            'conversion_quality': quality_score,
            'original_data_preserved': True,
            'import_timestamp': datetime.now().isoformat(),
            'unmapped_fields': adapter.get_unmapped_fields(),
            'warnings': adapter.get_warnings()
        }
        
        # 元データ保持（準可逆のため）
        theme_data['_original_data'] = raw_data
        
        return theme_data
    
    def export_theme(
        self,
        theme_data: Dict[str, Any],
        target_format: str = None
    ) -> Dict[str, Any]:
        """スマートエクスポート"""
        import_info = theme_data.get('_import_info', {})
        
        # ターゲット形式決定
        if target_forma
        exported_data = adapter.export_data(theme_data)
        
        # メタデータ埋め込み
        if import_metadata:
            exported_data['_qt_theme_studio_metadata'] = {
                'exported_from': 'Qt-Theme-Studio',
                'export_timestamp': datetime.now().isoformat(),
                'original_import': import_metadata,
                'reversible': True
            }
        
        return exported_data
```

#### JSON Schema自動推論
```python
class JSONSchemaAnalyzer:
    def infer_schema(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """JSON Schemaの自動推論"""
        schema = {
            "type": "object",
            "properties": {},
            "required": []
        }
        
        for key, value in data.items():
            schema["properties"][key] = self.infer_property_schema(value)
            
            # 必須フィールドの判定
            if self.is_required_field(key, value):
                schema["required"].append(key)
        
        return schema
    
    def infer_property_schema(self, value: Any) -> Dict[str, Any]:
        """プロパティスキーマの推論"""
        if isinstance(value, str):
            # 色コードパターンの検出
            if re.match(r'^#[0-9a-fA-F]{6}$', value):
                return {
                    "type": "string",
                    "pattern": "^#[0-9a-fA-F]{6}$",
                    "description": "Color code in hex format"
                }
            else:
                return {"type": "string"}
        
        elif isinstance(value, (int, float)):
            return {"type": "number"}
        
        elif isinstance(value, bool):
            return {"type": "boolean"}
        
        elif isinstance(value, dict):
            return {
                "type": "object",
                "properties": {
                    k: self.infer_property_schema(v) for k, v in value.items()
                }
            }
        
        elif isinstance(value, list):
            if value:
                return {
                    "type": "array",
                    "items": self.infer_property_schema(value[0])
                }
            else:
                return {"type": "array"}
        
        return {"type": "null"}
```

#### 動的アダプター生成
```python
class AdapterGenerator:
    def __init__(self):
        self.known_formats = self.load_known_formats()
        self.adapter_cache = {}
    
    def create_adapter(self, format_info: Dict[str, Any]) -> 'ThemeAdapter':
        """動的アダプター生成"""
        format_name = format_info['name']
        
        if format_name in self.adapter_cache:
            return self.adapter_cache[format_name]
        
        # 既知形式の確認
        if format_name in self.known_formats:
            adapter_class = self.known_formats[format_name]['adapter_class']
            adapter = adapter_class(format_info)
        else:
            # 汎用アダプターの生成
            adapter = self.generate_generic_adapter(format_info)
        
        self.adapter_cache[format_name] = adapter
        return adapter
    
    def generate_generic_adapter(self, format_info: Dict[str, Any]) -> 'GenericThemeAdapter':
        """汎用アダプターの生成"""
        schema = format_info['schema']
        mapping_rules = self.generate_mapping_rules(schema)
        
        return GenericThemeAdapter(
            format_info=format_info,
            mapping_rules=mapping_rules
        )
    
    def generate_mapping_rules(self, schema: Dict[str, Any]) -> Dict[str, str]:
        """マッピングルールの生成"""
        rules = {}
        
        # 色関連フィールドの検出
        color_fields = self.find_color_fields(schema)
        for field_path in color_fields:
            if 'primary' in field_path.lower():
                rules[field_path] = 'colors.primary'
            elif 'background' in field_path.lower():
                rules[field_path] = 'colors.background'
            elif 'text' in field_path.lower():
                rules[field_path] = 'colors.text'
            # その他のマッピングルール...
        
        return rules
```

### 5.3 UI仕様

#### インポート画面
```
┌─────────────────────────────────────────────────────────┐
│ 可逆インポート                                           │
├─────────────────────────────────────────────────────────┤
│ ファイル: [theme.json] [参照]                            │
├─────────────────────────────────────────────────────────┤
│ 形式検出結果:                                           │
│ ┌─────────────────────────────────────────────────────┐ │
│ │ 検出形式: VS Code Theme Format                      │ │
│ │ 信頼度: 95%                                         │ │
│ │ 構造: colors(12), fonts(3), properties(8)          │ │
│ │ メタデータ: author, version, description            │ │
│ └─────────────────────────────────────────────────────┘ │
├─────────────────────────────────────────────────────────┤
│ 変換プレビュー:                                         │
│ ┌─────────────────────────────────────────────────────┐ │
│ │ 元形式 → Qt-Theme-Studio形式                        │ │
│ │ "foreground": "#ffffff" → "colors.text": "#ffffff" │ │
│ │ "background": "#1e1e1e" → "colors.background": ... │ │
│ │ "accent": "#007acc" → "colors.primary": "#007acc"  │ │
│ └─────────────────────────────────────────────────────┘ │
├─────────────────────────────────────────────────────────┤
│ オプション:                                             │
│ ☑ メタデータを保持 (可逆変換用)                         │
│ ☑ 変換ログを記録                                       │
│ ☐ 不明フィールドを保持                                 │
├─────────────────────────────────────────────────────────┤
│ [インポート] [プレビュー更新] [キャンセル]                │
└─────────────────────────────────────────────────────────┘
```

#### エクスポート画面
```
┌─────────────────────────────────────────────────────────┐
│ 可逆エクスポート                                         │
├─────────────────────────────────────────────────────────┤
│ 元形式情報:                                             │
│ ┌─────────────────────────────────────────────────────┐ │
│ │ インポート元: VS Code Theme Format                   │ │
│ │ インポート日時: 2025-08-15 21:30:00                 │ │
│ │ 変換ログ: 12項目が正常に変換されました               │ │
│ └─────────────────────────────────────────────────────┘ │
├─────────────────────────────────────────────────────────┤
│ エクスポート形式:                                       │
│ ○ 元の形式 (VS Code Theme Format) - 推奨               │
│ ○ Qt-Theme-Studio標準形式                              │
│ ○ CSS Variables                                        │
│ ○ その他の形式...                                      │
├─────────────────────────────────────────────────────────┤
│ 可逆性チェック:                                         │
│ ┌─────────────────────────────────────────────────────┐ │
│ │ ✅ 完全可逆変換可能                                 │ │
│ │ ✅ メタデータ保持                                   │ │
│ │ ✅ 変更履歴追跡                                     │ │
│ │ ⚠️  カスタムフィールド1件が失われる可能性            │ │
│ └─────────────────────────────────────────────────────┘ │
├─────────────────────────────────────────────────────────┤
│ [エクスポート] [プレビュー] [設定]                       │
└─────────────────────────────────────────────────────────┘
```

## 6. プラグインシステム

### 6.1 概要
サードパーティ開発者がQt-Theme-Studioを拡張できるプラグインシステム。

### 4.2 プラグインAPI

#### 基本インターフェース
```python
from abc import ABC, abstractmethod
from typing import Dict, Any, List
from PySide6.QtWidgets import QWidget

class ThemeStudioPlugin(ABC):
    """プラグイン基底クラス"""
    
    @abstractmethod
    def get_metadata(self) -> Dict[str, Any]:
        """プラグインメタデータ"""
        return {
            "name": "Plugin Name",
            "version": "1.0.0",
            "author": "Author Name",
            "description": "Plugin description",
            "api_version": "1.0",
            "dependencies": []
        }
    
    @abstractmethod
    def initialize(self, context: 'PluginContext') -> bool:
        """プラグイン初期化"""
        pass
    
    @abstractmethod
    def create_widget(self) -> QWidget:
        """プラグインウィジェット作成"""
        pass
    
    @abstractmethod
    def process_theme(self, theme_data: Dict[str, Any]) -> Dict[str, Any]:
        """テーマデータ処理"""
        pass
    
    def cleanup(self):
        """クリーンアップ処理"""
        pass
```

#### プラグインコンテキスト
```python
class PluginContext:
    """プラグイン実行コンテキスト"""
    
    def __init__(self, app_instance):
        self.app = app_instance
        self.theme_manager = app_instance.theme_manager
        self.settings = app_instance.settings
    
    def get_current_theme(self) -> Dict[str, Any]:
        """現在のテーマ取得"""
        return self.theme_manager.get_current_theme()
    
    def set_theme(self, theme_data: Dict[str, Any]):
        """テーマ設定"""
        self.theme_manager.set_theme(theme_data)
    
    def show_notification(self, message: str, level: str = "info"):
        """通知表示"""
        self.app.show_notification(message, level)
    
    def register_menu_action(self, menu_path: str, action_name: str, callback):
        """メニューアクション登録"""
        self.app.register_plugin_action(menu_path, action_name, callback)
```

### 4.3 プラグイン例

#### カラーピッカープラグイン
```python
class ColorPickerPlugin(ThemeStudioPlugin):
    def get_metadata(self):
        return {
            "name": "Advanced Color Picker",
            "version": "1.0.0",
            "author": "Example Developer",
            "description": "高度なカラーピッカー機能"
        }
    
    def initialize(self, context):
        self.context = context
        context.register_menu_action(
            "Tools", "Advanced Color Picker", self.show_color_picker
        )
        return True
    
    def create_widget(self):
        return AdvancedColorPickerWidget()
    
    def show_color_picker(self):
        dialog = ColorPickerDialog()
        if dialog.exec():
            color = dialog.get_selected_color()
            # 現在のテーマに色を適用
            theme = self.context.get_current_theme()
            theme['colors']['primary'] = color
            self.context.set_theme(theme)
```

## 7. AI支援テーマ生成

### 7.1 概要
機械学習を活用した自動テーマ生成とユーザー好み学習機能。

### 5.2 機能要件

#### 自動テーマ生成
- **スタイル分析**: 既存テーマの特徴抽出
- **トレンド分析**: 人気テーマの傾向分析
- **ユーザー好み学習**: 使用履歴からの好み推定
- **コンテキスト考慮**: 用途に応じた最適化

#### 技術仕様
```python
class AIThemeGenerator:
    def __init__(self, model_path: str):
        self.model = self.load_model(model_path)
        self.feature_extractor = ColorFeatureExtractor()
    
    def generate_theme(
        self,
        style_preference: str,  # "modern", "classic", "vibrant"
        use_case: str,          # "web", "desktop", "mobile"
        base_colors: List[str] = None,
        user_history: List[Dict] = None
    ) -> Dict[str, Any]:
        """AI支援テーマ生成"""
        
        # 特徴量抽出
        features = self.extract_features(
            style_preference, use_case, base_colors, user_history
        )
        
        # モデル推論
        prediction = self.model.predict(features)
        
        # テーマデータ生成
        theme_data = self.prediction_to_theme(prediction)
        
        return theme_data
    
    def learn_from_feedback(
        self,
        theme_data: Dict[str, Any],
        user_rating: float,
        usage_duration: int
    ):
        """ユーザーフィードバックからの学習"""
        # 強化学習による好み更新
        pass
```

### 5.3 機械学習モデル

#### 特徴量設計
```python
class ColorFeatureExtractor:
    def extract_color_features(self, colors: List[str]) -> np.ndarray:
        """色特徴量抽出"""
        features = []
        
        for color in colors:
            h, s, l = rgb_to_hsl(hex_to_rgb(color))
            
            # 基本特徴量
            features.extend([h/360, s, l])
            
            # 色温度
            temp = self.calculate_color_temperature(color)
            features.append(temp / 10000)  # 正規化
            
            # 彩度・明度の分散
            features.append(self.calculate_saturation_variance(colors))
            features.append(self.calculate_lightness_variance(colors))
        
        return np.array(features)
    
    def extract_harmony_features(self, colors: List[str]) -> np.ndarray:
        """調和特徴量抽出"""
        # 色相差の分析
        hue_differences = self.calculate_hue_differences(colors)
        
        # 調和パターンの検出
        harmony_scores = {
            'complementary': self.detect_complementary(colors),
            'triadic': self.detect_triadic(colors),
            'analogous': self.detect_analogous(colors)
        }
        
        return np.array(list(harmony_scores.values()))
```

## 8. コラボレーション機能

### 8.1 概要
チームでのテーマ開発を支援するリアルタイム共同編集機能。

### 6.2 機能要件

#### リアルタイム同期
- **同時編集**: 複数ユーザーの同時編集
- **変更追跡**: 変更履歴の記録
- **競合解決**: 編集競合の自動解決
- **権限管理**: ユーザー権限の制御

#### 技術仕様
```python
class CollaborationManager:
    def __init__(self, websocket_url: str):
        self.ws_client = WebSocketClient(websocket_url)
        self.operation_queue = OperationQueue()
        self.conflict_resolver = ConflictResolver()
    
    def start_collaboration_session(self, theme_id: str, user_id: str):
        """コラボレーションセッション開始"""
        self.ws_client.connect()
        self.ws_client.join_room(theme_id, user_id)
        self.ws_client.on_message = self.handle_remote_operation
    
    def apply_local_operation(self, operation: 'ThemeOperation'):
        """ローカル操作適用"""
        # 操作的変換（Operational Transformation）
        transformed_op = self.operation_queue.transform(operation)
        
        # ローカル適用
        self.apply_operation(transformed_op)
        
        # リモート送信
        self.ws_client.send_operation(transformed_op)
    
    def handle_remote_operation(self, operation: 'ThemeOperation'):
        """リモート操作処理"""
        # 競合解決
        resolved_op = self.conflict_resolver.resolve(
            operation, self.operation_queue.get_pending()
        )
        
        # 適用
        self.apply_operation(resolved_op)
        
        # UI更新
        self.notify_ui_update(resolved_op)
```

#### 操作的変換
```python
class ThemeOperation:
    def __init__(self, op_type: str, path: str, value: Any, timestamp: int):
        self.type = op_type      # "set", "delete", "insert"
        self.path = path         # "colors.primary"
        self.value = value       # "#007acc"
        self.timestamp = timestamp
        self.user_id = None

class OperationalTransform:
    def transform(self, op1: ThemeOperation, op2: ThemeOperation) -> Tuple[ThemeOperation, ThemeOperation]:
        """2つの操作を変換"""
        if op1.path == op2.path:
            # 同じパスへの操作
            if op1.timestamp < op2.timestamp:
                # op1が先行
                return op1, self.transform_against(op2, op1)
            else:
                # op2が先行
                return self.transform_against(op1, op2), op2
        else:
            # 異なるパス - 変換不要
            return op1, op2
```

---

これらの仕様書に基づいて実装することで、高品質で一貫性のある機能を提供できます。各機能の実装時は、この仕様書を参考にしてください。